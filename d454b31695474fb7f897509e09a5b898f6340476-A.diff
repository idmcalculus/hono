diff --git a/src/client/circuit-breaker.test.ts b/src/client/circuit-breaker.test.ts
new file mode 100644
index 00000000..6b7c9836
--- /dev/null
+++ b/src/client/circuit-breaker.test.ts
@@ -0,0 +1,573 @@
+import { HttpResponse, http } from 'msw'
+import { setupServer } from 'msw/node'
+import { vi } from 'vitest'
+import { Hono } from '../hono'
+import { hc } from './client'
+import {
+  CircuitBreaker,
+  CircuitBreakerError,
+  createCircuitBreakerFetch,
+  createCircuitBreakerFetchWithBreaker,
+} from './circuit-breaker'
+import type { CircuitBreakerState } from './circuit-breaker'
+
+describe('CircuitBreaker', () => {
+  describe('Initial state', () => {
+    it('Should start in closed state', () => {
+      const breaker = new CircuitBreaker()
+      expect(breaker.getState()).toBe('closed')
+    })
+
+    it('Should start with zero failure count', () => {
+      const breaker = new CircuitBreaker()
+      expect(breaker.getFailureCount()).toBe(0)
+    })
+
+    it('Should allow requests in closed state', () => {
+      const breaker = new CircuitBreaker()
+      expect(breaker.canRequest()).toBe(true)
+    })
+  })
+
+  describe('State transitions', () => {
+    it('Should transition to open after reaching failure threshold', () => {
+      const breaker = new CircuitBreaker({ failureThreshold: 3 })
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('closed')
+      expect(breaker.getFailureCount()).toBe(1)
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('closed')
+      expect(breaker.getFailureCount()).toBe(2)
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('open')
+      expect(breaker.canRequest()).toBe(false)
+    })
+
+    it('Should transition to half-open after reset timeout', () => {
+      vi.useFakeTimers()
+
+      const breaker = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 5000,
+      })
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('open')
+
+      // Advance time but not enough
+      vi.advanceTimersByTime(3000)
+      expect(breaker.getState()).toBe('open')
+
+      // Advance time past the reset timeout
+      vi.advanceTimersByTime(3000)
+      expect(breaker.getState()).toBe('half-open')
+      expect(breaker.canRequest()).toBe(true)
+
+      vi.useRealTimers()
+    })
+
+    it('Should transition from half-open to closed on success', () => {
+      vi.useFakeTimers()
+
+      const breaker = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 1000,
+        successThreshold: 1,
+      })
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('open')
+
+      vi.advanceTimersByTime(1500)
+      expect(breaker.getState()).toBe('half-open')
+
+      breaker.recordSuccess()
+      expect(breaker.getState()).toBe('closed')
+      expect(breaker.getFailureCount()).toBe(0)
+
+      vi.useRealTimers()
+    })
+
+    it('Should transition from half-open to open on failure', () => {
+      vi.useFakeTimers()
+
+      const breaker = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 1000,
+      })
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('open')
+
+      vi.advanceTimersByTime(1500)
+      expect(breaker.getState()).toBe('half-open')
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('open')
+
+      vi.useRealTimers()
+    })
+
+    it('Should require multiple successes when successThreshold > 1', () => {
+      vi.useFakeTimers()
+
+      const breaker = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 1000,
+        successThreshold: 3,
+      })
+
+      breaker.recordFailure()
+      vi.advanceTimersByTime(1500)
+      expect(breaker.getState()).toBe('half-open')
+
+      breaker.recordSuccess()
+      expect(breaker.getState()).toBe('half-open')
+      expect(breaker.getSuccessCount()).toBe(1)
+
+      breaker.recordSuccess()
+      expect(breaker.getState()).toBe('half-open')
+      expect(breaker.getSuccessCount()).toBe(2)
+
+      breaker.recordSuccess()
+      expect(breaker.getState()).toBe('closed')
+
+      vi.useRealTimers()
+    })
+  })
+
+  describe('Success handling', () => {
+    it('Should reset failure count on success in closed state', () => {
+      const breaker = new CircuitBreaker({ failureThreshold: 5 })
+
+      breaker.recordFailure()
+      breaker.recordFailure()
+      expect(breaker.getFailureCount()).toBe(2)
+
+      breaker.recordSuccess()
+      expect(breaker.getFailureCount()).toBe(0)
+    })
+  })
+
+  describe('Callbacks', () => {
+    it('Should call onStateChange when state changes', () => {
+      const onStateChange = vi.fn()
+      const breaker = new CircuitBreaker({
+        failureThreshold: 1,
+        onStateChange,
+      })
+
+      breaker.recordFailure()
+      expect(onStateChange).toHaveBeenCalledWith('open', 'closed')
+    })
+
+    it('Should call onFailure when a failure is recorded', () => {
+      const onFailure = vi.fn()
+      const breaker = new CircuitBreaker({ onFailure })
+      const error = new Error('test error')
+
+      breaker.recordFailure(error)
+      expect(onFailure).toHaveBeenCalledWith(error)
+    })
+
+    it('Should call onSuccess when a success is recorded', () => {
+      const onSuccess = vi.fn()
+      const breaker = new CircuitBreaker({ onSuccess })
+
+      breaker.recordSuccess()
+      expect(onSuccess).toHaveBeenCalled()
+    })
+  })
+
+  describe('Manual reset', () => {
+    it('Should reset to closed state', () => {
+      const breaker = new CircuitBreaker({ failureThreshold: 1 })
+
+      breaker.recordFailure()
+      expect(breaker.getState()).toBe('open')
+
+      breaker.reset()
+      expect(breaker.getState()).toBe('closed')
+      expect(breaker.getFailureCount()).toBe(0)
+      expect(breaker.getSuccessCount()).toBe(0)
+    })
+  })
+
+  describe('Time tracking', () => {
+    it('Should return time until half-open', () => {
+      vi.useFakeTimers()
+
+      const breaker = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 10000,
+      })
+
+      breaker.recordFailure()
+      expect(breaker.getTimeUntilHalfOpen()).toBe(10000)
+
+      vi.advanceTimersByTime(3000)
+      expect(breaker.getTimeUntilHalfOpen()).toBe(7000)
+
+      vi.useRealTimers()
+    })
+
+    it('Should return 0 when not in open state', () => {
+      const breaker = new CircuitBreaker()
+      expect(breaker.getTimeUntilHalfOpen()).toBe(0)
+    })
+  })
+
+  describe('Failure status codes', () => {
+    it('Should treat 5xx responses as failures by default', () => {
+      const breaker = new CircuitBreaker()
+
+      expect(breaker.isFailureResponse(new Response(null, { status: 500 }))).toBe(true)
+      expect(breaker.isFailureResponse(new Response(null, { status: 502 }))).toBe(true)
+      expect(breaker.isFailureResponse(new Response(null, { status: 503 }))).toBe(true)
+    })
+
+    it('Should not treat 4xx responses as failures by default', () => {
+      const breaker = new CircuitBreaker()
+
+      expect(breaker.isFailureResponse(new Response(null, { status: 400 }))).toBe(false)
+      expect(breaker.isFailureResponse(new Response(null, { status: 404 }))).toBe(false)
+      expect(breaker.isFailureResponse(new Response(null, { status: 429 }))).toBe(false)
+    })
+
+    it('Should use custom failure status codes', () => {
+      const breaker = new CircuitBreaker({
+        failureStatusCodes: [500, 502, 503, 429],
+      })
+
+      expect(breaker.isFailureResponse(new Response(null, { status: 429 }))).toBe(true)
+      expect(breaker.isFailureResponse(new Response(null, { status: 501 }))).toBe(false)
+    })
+  })
+})
+
+describe('CircuitBreakerError', () => {
+  it('Should have correct properties', () => {
+    const error = new CircuitBreakerError('http://example.com/api', 5000)
+
+    expect(error.name).toBe('CircuitBreakerError')
+    expect(error.url).toBe('http://example.com/api')
+    expect(error.circuitState).toBe('open')
+    expect(error.retryAfter).toBe(5000)
+    expect(error.message).toContain('Circuit breaker is open')
+    expect(error.message).toContain('http://example.com/api')
+  })
+})
+
+describe('createCircuitBreakerFetch', () => {
+  const server = setupServer(
+    http.get('http://localhost/success', () => {
+      return HttpResponse.json({ ok: true })
+    }),
+    http.get('http://localhost/server-error', () => {
+      return HttpResponse.json({ error: 'Internal Server Error' }, { status: 500 })
+    }),
+    http.get('http://localhost/bad-request', () => {
+      return HttpResponse.json({ error: 'Bad Request' }, { status: 400 })
+    })
+  )
+
+  beforeAll(() => server.listen())
+  afterEach(() => server.resetHandlers())
+  afterAll(() => server.close())
+
+  it('Should pass through successful requests', async () => {
+    const circuitBreakerFetch = createCircuitBreakerFetch()
+    const response = await circuitBreakerFetch('http://localhost/success')
+
+    expect(response.ok).toBe(true)
+    const data = await response.json()
+    expect(data).toEqual({ ok: true })
+  })
+
+  it('Should pass through 4xx responses without recording failure', async () => {
+    const onFailure = vi.fn()
+    const circuitBreakerFetch = createCircuitBreakerFetch({ onFailure })
+
+    const response = await circuitBreakerFetch('http://localhost/bad-request')
+
+    expect(response.status).toBe(400)
+    expect(onFailure).not.toHaveBeenCalled()
+  })
+
+  it('Should record failure for 5xx responses', async () => {
+    const onFailure = vi.fn()
+    const circuitBreakerFetch = createCircuitBreakerFetch({ onFailure })
+
+    const response = await circuitBreakerFetch('http://localhost/server-error')
+
+    expect(response.status).toBe(500)
+    expect(onFailure).toHaveBeenCalled()
+  })
+
+  it('Should throw CircuitBreakerError when circuit is open', async () => {
+    const circuitBreakerFetch = createCircuitBreakerFetch({
+      failureThreshold: 1,
+      resetTimeout: 30000,
+    })
+
+    // Trigger a failure to open the circuit
+    await circuitBreakerFetch('http://localhost/server-error')
+
+    // Next request should be blocked
+    await expect(circuitBreakerFetch('http://localhost/success')).rejects.toThrow(
+      CircuitBreakerError
+    )
+  })
+
+  it('Should call onRequestBlocked when request is blocked', async () => {
+    const onRequestBlocked = vi.fn()
+    const circuitBreakerFetch = createCircuitBreakerFetch({
+      failureThreshold: 1,
+      onRequestBlocked,
+    })
+
+    await circuitBreakerFetch('http://localhost/server-error')
+
+    try {
+      await circuitBreakerFetch('http://localhost/success')
+    } catch {
+      // Expected
+    }
+
+    expect(onRequestBlocked).toHaveBeenCalledWith('http://localhost/success')
+  })
+
+  it('Should handle network errors', async () => {
+    server.use(
+      http.get('http://localhost/network-error', () => {
+        return HttpResponse.error()
+      })
+    )
+
+    const onFailure = vi.fn()
+    const circuitBreakerFetch = createCircuitBreakerFetch({ onFailure })
+
+    await expect(circuitBreakerFetch('http://localhost/network-error')).rejects.toThrow()
+    expect(onFailure).toHaveBeenCalled()
+  })
+
+  it('Should track state changes correctly', async () => {
+    vi.useFakeTimers()
+
+    const stateChanges: Array<{ state: CircuitBreakerState; previous: CircuitBreakerState }> = []
+    const circuitBreakerFetch = createCircuitBreakerFetch({
+      failureThreshold: 1,
+      resetTimeout: 5000,
+      onStateChange: (state, previous) => {
+        stateChanges.push({ state, previous })
+      },
+    })
+
+    // Trigger failure -> open
+    await circuitBreakerFetch('http://localhost/server-error')
+    expect(stateChanges).toEqual([{ state: 'open', previous: 'closed' }])
+
+    // Wait for half-open
+    vi.advanceTimersByTime(6000)
+
+    // Success -> closed
+    await circuitBreakerFetch('http://localhost/success')
+    expect(stateChanges).toEqual([
+      { state: 'open', previous: 'closed' },
+      { state: 'half-open', previous: 'open' },
+      { state: 'closed', previous: 'half-open' },
+    ])
+
+    vi.useRealTimers()
+  })
+})
+
+describe('createCircuitBreakerFetchWithBreaker', () => {
+  const server = setupServer(
+    http.get('http://localhost/success', () => {
+      return HttpResponse.json({ ok: true })
+    }),
+    http.get('http://localhost/server-error', () => {
+      return HttpResponse.json({ error: 'Internal Server Error' }, { status: 500 })
+    })
+  )
+
+  beforeAll(() => server.listen())
+  afterEach(() => server.resetHandlers())
+  afterAll(() => server.close())
+
+  it('Should return both fetch and breaker', () => {
+    const result = createCircuitBreakerFetchWithBreaker()
+
+    expect(typeof result.fetch).toBe('function')
+    expect(result.breaker).toBeInstanceOf(CircuitBreaker)
+  })
+
+  it('Should allow manual control of circuit breaker', async () => {
+    const { fetch: circuitBreakerFetch, breaker } = createCircuitBreakerFetchWithBreaker({
+      failureThreshold: 1,
+    })
+
+    // Open the circuit
+    await circuitBreakerFetch('http://localhost/server-error')
+    expect(breaker.getState()).toBe('open')
+
+    // Manual reset
+    breaker.reset()
+    expect(breaker.getState()).toBe('closed')
+
+    // Now request should work
+    const response = await circuitBreakerFetch('http://localhost/success')
+    expect(response.ok).toBe(true)
+  })
+
+  it('Should allow monitoring circuit state', async () => {
+    const { fetch: circuitBreakerFetch, breaker } = createCircuitBreakerFetchWithBreaker({
+      failureThreshold: 3,
+    })
+
+    await circuitBreakerFetch('http://localhost/server-error')
+    expect(breaker.getFailureCount()).toBe(1)
+
+    await circuitBreakerFetch('http://localhost/server-error')
+    expect(breaker.getFailureCount()).toBe(2)
+
+    await circuitBreakerFetch('http://localhost/success')
+    expect(breaker.getFailureCount()).toBe(0) // Reset on success
+  })
+})
+
+describe('Integration with hc client', () => {
+  const app = new Hono()
+    .get('/success', (c) => c.json({ ok: true }))
+    .get('/server-error', (c) => c.json({ error: 'Internal Server Error' }, 500))
+    .get('/data/:id', (c) => c.json({ id: c.req.param('id') }))
+
+  type AppType = typeof app
+
+  const server = setupServer(
+    http.get('http://localhost/success', () => {
+      return HttpResponse.json({ ok: true })
+    }),
+    http.get('http://localhost/server-error', () => {
+      return HttpResponse.json({ error: 'Internal Server Error' }, { status: 500 })
+    }),
+    http.get('http://localhost/data/:id', ({ params }) => {
+      return HttpResponse.json({ id: params.id })
+    })
+  )
+
+  beforeAll(() => server.listen())
+  afterEach(() => server.resetHandlers())
+  afterAll(() => server.close())
+
+  it('Should work with hc client', async () => {
+    const circuitBreakerFetch = createCircuitBreakerFetch()
+    const client = hc<AppType>('http://localhost', {
+      fetch: circuitBreakerFetch,
+    })
+
+    const res = await client.success.$get()
+    expect(res.ok).toBe(true)
+
+    const data = await res.json()
+    expect(data).toEqual({ ok: true })
+  })
+
+  it('Should protect hc client from cascading failures', async () => {
+    const circuitBreakerFetch = createCircuitBreakerFetch({
+      failureThreshold: 2,
+    })
+    const client = hc<AppType>('http://localhost', {
+      fetch: circuitBreakerFetch,
+    })
+
+    // First two 5xx responses trigger circuit open
+    await client['server-error'].$get()
+    await client['server-error'].$get()
+
+    // Third request should be blocked
+    await expect(client.success.$get()).rejects.toThrow(CircuitBreakerError)
+  })
+
+  it('Should allow different circuit breakers per client', async () => {
+    const { fetch: fetch1, breaker: breaker1 } = createCircuitBreakerFetchWithBreaker({
+      failureThreshold: 1,
+    })
+    const { fetch: fetch2, breaker: breaker2 } = createCircuitBreakerFetchWithBreaker({
+      failureThreshold: 1,
+    })
+
+    const client1 = hc<AppType>('http://localhost', { fetch: fetch1 })
+    const client2 = hc<AppType>('http://localhost', { fetch: fetch2 })
+
+    // Open circuit for client1
+    await client1['server-error'].$get()
+    expect(breaker1.getState()).toBe('open')
+
+    // Client2 should still work
+    expect(breaker2.getState()).toBe('closed')
+    const res = await client2.success.$get()
+    expect(res.ok).toBe(true)
+  })
+
+  it('Should work with path parameters', async () => {
+    const circuitBreakerFetch = createCircuitBreakerFetch()
+    const client = hc<AppType>('http://localhost', {
+      fetch: circuitBreakerFetch,
+    })
+
+    const res = await client.data[':id'].$get({
+      param: { id: '123' },
+    })
+
+    expect(res.ok).toBe(true)
+    const data = await res.json()
+    expect(data).toEqual({ id: '123' })
+  })
+
+  it('Should handle recovery after circuit opens', async () => {
+    vi.useFakeTimers()
+
+    const { fetch: circuitBreakerFetch, breaker } = createCircuitBreakerFetchWithBreaker({
+      failureThreshold: 1,
+      resetTimeout: 5000,
+    })
+    const client = hc<AppType>('http://localhost', {
+      fetch: circuitBreakerFetch,
+    })
+
+    // Open the circuit
+    await client['server-error'].$get()
+    expect(breaker.getState()).toBe('open')
+
+    // Wait for half-open
+    vi.advanceTimersByTime(6000)
+    expect(breaker.getState()).toBe('half-open')
+
+    // Successful request should close the circuit
+    const res = await client.success.$get()
+    expect(res.ok).toBe(true)
+    expect(breaker.getState()).toBe('closed')
+
+    vi.useRealTimers()
+  })
+
+  it('Should work with custom base fetch', async () => {
+    const customFetchMock = vi.fn().mockResolvedValue(new Response(JSON.stringify({ ok: true }), {
+      status: 200,
+      headers: { 'content-type': 'application/json' },
+    }))
+
+    const circuitBreakerFetch = createCircuitBreakerFetch({}, customFetchMock)
+    const client = hc<AppType>('http://localhost', {
+      fetch: circuitBreakerFetch,
+    })
+
+    await client.success.$get()
+    expect(customFetchMock).toHaveBeenCalled()
+  })
+})
diff --git a/src/client/circuit-breaker.ts b/src/client/circuit-breaker.ts
new file mode 100644
index 00000000..3f3d6c73
--- /dev/null
+++ b/src/client/circuit-breaker.ts
@@ -0,0 +1,378 @@
+/**
+ * Circuit Breaker implementation for the Hono RPC client (hc).
+ *
+ * The circuit breaker pattern prevents cascading failures by temporarily
+ * blocking requests to a failing service, giving it time to recover.
+ *
+ * States:
+ * - Closed: Normal operation, requests pass through
+ * - Open: Requests are blocked after failure threshold is reached
+ * - HalfOpen: Limited requests allowed to test if service has recovered
+ */
+
+/**
+ * Circuit breaker states
+ */
+export type CircuitBreakerState = 'closed' | 'open' | 'half-open'
+
+/**
+ * Configuration options for the circuit breaker
+ */
+export interface CircuitBreakerOptions {
+  /**
+   * Number of consecutive failures before the circuit opens.
+   * @default 5
+   */
+  failureThreshold?: number
+
+  /**
+   * Time in milliseconds the circuit stays open before transitioning to half-open.
+   * @default 30000 (30 seconds)
+   */
+  resetTimeout?: number
+
+  /**
+   * Number of successful requests in half-open state required to close the circuit.
+   * @default 1
+   */
+  successThreshold?: number
+
+  /**
+   * HTTP status codes that should be considered failures.
+   * By default, only 5xx errors are considered failures.
+   * @default [500, 501, 502, 503, 504, 505, 506, 507, 508, 510, 511]
+   */
+  failureStatusCodes?: number[]
+
+  /**
+   * Optional callback when the circuit state changes.
+   */
+  onStateChange?: (state: CircuitBreakerState, previousState: CircuitBreakerState) => void
+
+  /**
+   * Optional callback when a request is blocked by the open circuit.
+   */
+  onRequestBlocked?: (url: string) => void
+
+  /**
+   * Optional callback when a failure is recorded.
+   */
+  onFailure?: (error: Error | Response) => void
+
+  /**
+   * Optional callback when a success is recorded.
+   */
+  onSuccess?: () => void
+}
+
+/**
+ * Error thrown when a request is blocked because the circuit is open.
+ */
+export class CircuitBreakerError extends Error {
+  /**
+   * The URL that was blocked.
+   */
+  public readonly url: string
+
+  /**
+   * The current state of the circuit breaker (always 'open' when this error is thrown).
+   */
+  public readonly circuitState: CircuitBreakerState
+
+  /**
+   * Time in milliseconds until the circuit will transition to half-open.
+   */
+  public readonly retryAfter: number
+
+  constructor(url: string, retryAfter: number) {
+    super(`Circuit breaker is open. Request to ${url} blocked.`)
+    this.name = 'CircuitBreakerError'
+    this.url = url
+    this.circuitState = 'open'
+    this.retryAfter = retryAfter
+  }
+}
+
+const DEFAULT_FAILURE_STATUS_CODES = [500, 501, 502, 503, 504, 505, 506, 507, 508, 510, 511]
+
+/**
+ * Circuit breaker class that tracks failures and manages state transitions.
+ */
+export class CircuitBreaker {
+  private state: CircuitBreakerState = 'closed'
+  private failureCount = 0
+  private successCount = 0
+  private lastFailureTime = 0
+
+  private readonly failureThreshold: number
+  private readonly resetTimeout: number
+  private readonly successThreshold: number
+  private readonly failureStatusCodes: Set<number>
+  private readonly onStateChange?: (
+    state: CircuitBreakerState,
+    previousState: CircuitBreakerState
+  ) => void
+  private readonly onRequestBlocked?: (url: string) => void
+  private readonly onFailure?: (error: Error | Response) => void
+  private readonly onSuccess?: () => void
+
+  constructor(options: CircuitBreakerOptions = {}) {
+    this.failureThreshold = options.failureThreshold ?? 5
+    this.resetTimeout = options.resetTimeout ?? 30000
+    this.successThreshold = options.successThreshold ?? 1
+    this.failureStatusCodes = new Set(options.failureStatusCodes ?? DEFAULT_FAILURE_STATUS_CODES)
+    this.onStateChange = options.onStateChange
+    this.onRequestBlocked = options.onRequestBlocked
+    this.onFailure = options.onFailure
+    this.onSuccess = options.onSuccess
+  }
+
+  /**
+   * Returns the current state of the circuit breaker.
+   */
+  getState(): CircuitBreakerState {
+    this.checkStateTransition()
+    return this.state
+  }
+
+  /**
+   * Returns the current failure count.
+   */
+  getFailureCount(): number {
+    return this.failureCount
+  }
+
+  /**
+   * Returns the current success count (relevant in half-open state).
+   */
+  getSuccessCount(): number {
+    return this.successCount
+  }
+
+  /**
+   * Returns the time remaining until the circuit transitions to half-open (in ms).
+   * Returns 0 if the circuit is not open.
+   */
+  getTimeUntilHalfOpen(): number {
+    if (this.state !== 'open') {
+      return 0
+    }
+    const elapsed = Date.now() - this.lastFailureTime
+    return Math.max(0, this.resetTimeout - elapsed)
+  }
+
+  /**
+   * Checks if a request should be allowed through.
+   * @returns true if the request is allowed, false if it should be blocked
+   */
+  canRequest(): boolean {
+    this.checkStateTransition()
+    return this.state !== 'open'
+  }
+
+  /**
+   * Records a successful request.
+   * In half-open state, increments success count and may close the circuit.
+   * In closed state, resets the failure count.
+   */
+  recordSuccess(): void {
+    this.checkStateTransition()
+
+    if (this.state === 'half-open') {
+      this.successCount++
+      this.onSuccess?.()
+
+      if (this.successCount >= this.successThreshold) {
+        this.transitionTo('closed')
+        this.failureCount = 0
+        this.successCount = 0
+      }
+    } else if (this.state === 'closed') {
+      // Reset failure count on success in closed state
+      this.failureCount = 0
+      this.onSuccess?.()
+    }
+  }
+
+  /**
+   * Records a failed request.
+   * Increments failure count and may open the circuit.
+   */
+  recordFailure(error?: Error | Response): void {
+    this.checkStateTransition()
+
+    if (this.state === 'half-open') {
+      // Any failure in half-open state reopens the circuit
+      this.transitionTo('open')
+      this.lastFailureTime = Date.now()
+      this.successCount = 0
+      if (error) {
+        this.onFailure?.(error)
+      }
+    } else if (this.state === 'closed') {
+      this.failureCount++
+      if (error) {
+        this.onFailure?.(error)
+      }
+
+      if (this.failureCount >= this.failureThreshold) {
+        this.transitionTo('open')
+        this.lastFailureTime = Date.now()
+      }
+    }
+  }
+
+  /**
+   * Checks if a response should be treated as a failure based on status code.
+   */
+  isFailureResponse(response: Response): boolean {
+    return this.failureStatusCodes.has(response.status)
+  }
+
+  /**
+   * Manually resets the circuit breaker to closed state.
+   */
+  reset(): void {
+    this.transitionTo('closed')
+    this.failureCount = 0
+    this.successCount = 0
+    this.lastFailureTime = 0
+  }
+
+  /**
+   * Checks if a state transition should occur based on elapsed time.
+   */
+  private checkStateTransition(): void {
+    if (this.state === 'open') {
+      const elapsed = Date.now() - this.lastFailureTime
+      if (elapsed >= this.resetTimeout) {
+        this.transitionTo('half-open')
+        this.successCount = 0
+      }
+    }
+  }
+
+  /**
+   * Transitions to a new state and calls the state change callback.
+   */
+  private transitionTo(newState: CircuitBreakerState): void {
+    if (this.state !== newState) {
+      const previousState = this.state
+      this.state = newState
+      this.onStateChange?.(newState, previousState)
+    }
+  }
+}
+
+/**
+ * Creates a fetch function wrapped with circuit breaker protection.
+ *
+ * @example
+ * ```ts
+ * const circuitBreakerFetch = createCircuitBreakerFetch({
+ *   failureThreshold: 5,
+ *   resetTimeout: 30000,
+ *   onStateChange: (state, prev) => console.log(`Circuit: ${prev} -> ${state}`)
+ * })
+ *
+ * const client = hc<AppType>('http://localhost', {
+ *   fetch: circuitBreakerFetch
+ * })
+ * ```
+ *
+ * @param options Circuit breaker configuration options
+ * @param baseFetch Optional custom fetch function to wrap (defaults to global fetch)
+ * @returns A fetch function with circuit breaker protection
+ */
+export function createCircuitBreakerFetch(
+  options: CircuitBreakerOptions = {},
+  baseFetch: typeof fetch = fetch
+): typeof fetch {
+  const breaker = new CircuitBreaker(options)
+
+  return async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
+    const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url
+
+    // Check if request is allowed
+    if (!breaker.canRequest()) {
+      options.onRequestBlocked?.(url)
+      throw new CircuitBreakerError(url, breaker.getTimeUntilHalfOpen())
+    }
+
+    try {
+      const response = await baseFetch(input, init)
+
+      // Check if response indicates a failure
+      if (breaker.isFailureResponse(response)) {
+        breaker.recordFailure(response)
+      } else {
+        breaker.recordSuccess()
+      }
+
+      return response
+    } catch (error) {
+      // Network errors, timeouts, etc.
+      breaker.recordFailure(error instanceof Error ? error : new Error(String(error)))
+      throw error
+    }
+  }
+}
+
+/**
+ * Creates a circuit breaker fetch with access to the underlying CircuitBreaker instance.
+ * This allows manual control and monitoring of the circuit breaker state.
+ *
+ * @example
+ * ```ts
+ * const { fetch: circuitBreakerFetch, breaker } = createCircuitBreakerFetchWithBreaker({
+ *   failureThreshold: 3
+ * })
+ *
+ * const client = hc<AppType>('http://localhost', {
+ *   fetch: circuitBreakerFetch
+ * })
+ *
+ * // Monitor or manually control the circuit
+ * console.log(breaker.getState()) // 'closed'
+ * breaker.reset() // Manually reset if needed
+ * ```
+ *
+ * @param options Circuit breaker configuration options
+ * @param baseFetch Optional custom fetch function to wrap (defaults to global fetch)
+ * @returns An object containing both the fetch function and the circuit breaker instance
+ */
+export function createCircuitBreakerFetchWithBreaker(
+  options: CircuitBreakerOptions = {},
+  baseFetch: typeof fetch = fetch
+): { fetch: typeof fetch; breaker: CircuitBreaker } {
+  const breaker = new CircuitBreaker(options)
+
+  const wrappedFetch = async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
+    const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url
+
+    // Check if request is allowed
+    if (!breaker.canRequest()) {
+      options.onRequestBlocked?.(url)
+      throw new CircuitBreakerError(url, breaker.getTimeUntilHalfOpen())
+    }
+
+    try {
+      const response = await baseFetch(input, init)
+
+      // Check if response indicates a failure
+      if (breaker.isFailureResponse(response)) {
+        breaker.recordFailure(response)
+      } else {
+        breaker.recordSuccess()
+      }
+
+      return response
+    } catch (error) {
+      // Network errors, timeouts, etc.
+      breaker.recordFailure(error instanceof Error ? error : new Error(String(error)))
+      throw error
+    }
+  }
+
+  return { fetch: wrappedFetch, breaker }
+}
diff --git a/src/client/index.ts b/src/client/index.ts
index b9508466..e64b3b16 100644
--- a/src/client/index.ts
+++ b/src/client/index.ts
@@ -5,6 +5,12 @@
 
 export { hc } from './client'
 export { parseResponse, DetailedError } from './utils'
+export {
+  CircuitBreaker,
+  CircuitBreakerError,
+  createCircuitBreakerFetch,
+  createCircuitBreakerFetchWithBreaker,
+} from './circuit-breaker'
 export type {
   InferResponseType,
   InferRequestType,
@@ -13,3 +19,7 @@ export type {
   ClientRequest,
   ClientResponse,
 } from './types'
+export type {
+  CircuitBreakerOptions,
+  CircuitBreakerState,
+} from './circuit-breaker'
