diff --git a/src/client/circuit-breaker.test.ts b/src/client/circuit-breaker.test.ts
new file mode 100644
index 00000000..789528e2
--- /dev/null
+++ b/src/client/circuit-breaker.test.ts
@@ -0,0 +1,807 @@
+import { HttpResponse, http } from 'msw'
+import { setupServer } from 'msw/node'
+import { vi } from 'vitest'
+import { Hono } from '../hono'
+import {
+  CircuitBreaker,
+  CircuitBreakerError,
+  createCircuitBreakerFetch,
+  withCircuitBreaker,
+} from './circuit-breaker'
+import type { CircuitBreakerState } from './circuit-breaker'
+
+describe('CircuitBreaker', () => {
+  describe('Initial state', () => {
+    it('Should start in closed state', () => {
+      const cb = new CircuitBreaker()
+      expect(cb.getState()).toBe('closed')
+    })
+
+    it('Should have zero failure count initially', () => {
+      const cb = new CircuitBreaker()
+      expect(cb.getFailureCount()).toBe(0)
+    })
+
+    it('Should have zero success count initially', () => {
+      const cb = new CircuitBreaker()
+      expect(cb.getSuccessCount()).toBe(0)
+    })
+
+    it('Should allow requests in closed state', () => {
+      const cb = new CircuitBreaker()
+      expect(cb.isAllowingRequests()).toBe(true)
+    })
+  })
+
+  describe('Configuration', () => {
+    it('Should use default values when no options provided', () => {
+      const cb = new CircuitBreaker()
+      expect(cb.getState()).toBe('closed')
+      expect(cb.isAllowingRequests()).toBe(true)
+    })
+
+    it('Should accept custom failure threshold', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 3 })
+      const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(mockFetch)
+
+      // First 2 failures should keep circuit closed
+      for (let i = 0; i < 2; i++) {
+        try {
+          await wrappedFetch('http://localhost')
+        } catch {
+          // Expected
+        }
+      }
+      expect(cb.getState()).toBe('closed')
+
+      // 3rd failure should open circuit
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+      expect(cb.getState()).toBe('open')
+    })
+
+    it('Should accept custom failure status codes', async () => {
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        failureStatusCodes: [429], // Only treat 429 as failure
+      })
+      const wrappedFetch = cb.wrapFetch(
+        vi.fn().mockResolvedValue(new Response(null, { status: 500 }))
+      )
+
+      // 500 should NOT be treated as failure with custom config
+      await wrappedFetch('http://localhost')
+      expect(cb.getState()).toBe('closed')
+      expect(cb.getFailureCount()).toBe(0)
+
+      // Now test with 429
+      const wrappedFetch429 = cb.wrapFetch(
+        vi.fn().mockResolvedValue(new Response(null, { status: 429 }))
+      )
+      await wrappedFetch429('http://localhost')
+      expect(cb.getState()).toBe('open')
+    })
+  })
+
+  describe('State transitions', () => {
+    it('Should transition to open after failure threshold', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 3 })
+      const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(mockFetch)
+
+      for (let i = 0; i < 3; i++) {
+        try {
+          await wrappedFetch('http://localhost')
+        } catch {
+          // Expected
+        }
+      }
+
+      expect(cb.getState()).toBe('open')
+      expect(cb.getFailureCount()).toBe(3)
+    })
+
+    it('Should reject requests when circuit is open', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+      const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(mockFetch)
+
+      // Open the circuit
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+      expect(cb.getState()).toBe('open')
+
+      // Subsequent requests should be rejected
+      await expect(wrappedFetch('http://localhost/test')).rejects.toThrow(CircuitBreakerError)
+      await expect(wrappedFetch('http://localhost/test')).rejects.toThrow(
+        'Circuit breaker is open'
+      )
+    })
+
+    it('Should transition to half-open after reset timeout', async () => {
+      vi.useFakeTimers()
+
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 5000,
+      })
+      const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(mockFetch)
+
+      // Open the circuit
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+      expect(cb.getState()).toBe('open')
+
+      // Advance time past reset timeout
+      vi.advanceTimersByTime(5001)
+
+      // Circuit should now allow requests (half-open)
+      expect(cb.isAllowingRequests()).toBe(true)
+      expect(cb.getState()).toBe('half-open')
+
+      vi.useRealTimers()
+    })
+
+    it('Should transition to closed after success threshold in half-open', async () => {
+      vi.useFakeTimers()
+
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        successThreshold: 2,
+        resetTimeout: 5000,
+      })
+
+      // Open the circuit
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFailingFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFailingFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+      expect(cb.getState()).toBe('open')
+
+      // Advance time to half-open
+      vi.advanceTimersByTime(5001)
+      expect(cb.isAllowingRequests()).toBe(true)
+      expect(cb.getState()).toBe('half-open')
+
+      // Successful requests in half-open
+      const successFetch = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))
+      const wrappedSuccessFetch = cb.wrapFetch(successFetch)
+
+      await wrappedSuccessFetch('http://localhost')
+      expect(cb.getState()).toBe('half-open')
+      expect(cb.getSuccessCount()).toBe(1)
+
+      await wrappedSuccessFetch('http://localhost')
+      expect(cb.getState()).toBe('closed')
+      expect(cb.getSuccessCount()).toBe(0) // Reset after closing
+      expect(cb.getFailureCount()).toBe(0) // Reset after closing
+
+      vi.useRealTimers()
+    })
+
+    it('Should transition back to open on failure in half-open', async () => {
+      vi.useFakeTimers()
+
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 5000,
+      })
+
+      // Open the circuit
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFailingFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFailingFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+
+      // Advance time to half-open
+      vi.advanceTimersByTime(5001)
+      expect(cb.isAllowingRequests()).toBe(true)
+      expect(cb.getState()).toBe('half-open')
+
+      // Failure in half-open should immediately open circuit
+      try {
+        await wrappedFailingFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+      expect(cb.getState()).toBe('open')
+
+      vi.useRealTimers()
+    })
+
+    it('Should reset failure count on success in closed state', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 5 })
+
+      // Record some failures
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFailingFetch = cb.wrapFetch(failingFetch)
+
+      for (let i = 0; i < 3; i++) {
+        try {
+          await wrappedFailingFetch('http://localhost')
+        } catch {
+          // Expected
+        }
+      }
+      expect(cb.getFailureCount()).toBe(3)
+
+      // Success should reset failure count
+      const successFetch = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))
+      const wrappedSuccessFetch = cb.wrapFetch(successFetch)
+      await wrappedSuccessFetch('http://localhost')
+
+      expect(cb.getFailureCount()).toBe(0)
+      expect(cb.getState()).toBe('closed')
+    })
+  })
+
+  describe('HTTP status code handling', () => {
+    it('Should treat 5xx responses as failures', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+
+      const mockFetch = vi.fn().mockResolvedValue(new Response(null, { status: 500 }))
+      const wrappedFetch = cb.wrapFetch(mockFetch)
+
+      await wrappedFetch('http://localhost')
+      expect(cb.getState()).toBe('open')
+    })
+
+    it('Should treat 2xx responses as successes', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+
+      const mockFetch = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))
+      const wrappedFetch = cb.wrapFetch(mockFetch)
+
+      await wrappedFetch('http://localhost')
+      expect(cb.getState()).toBe('closed')
+      expect(cb.getFailureCount()).toBe(0)
+    })
+
+    it('Should treat 4xx responses as successes (client errors)', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+
+      const mockFetch = vi.fn().mockResolvedValue(new Response(null, { status: 404 }))
+      const wrappedFetch = cb.wrapFetch(mockFetch)
+
+      await wrappedFetch('http://localhost')
+      expect(cb.getState()).toBe('closed')
+      expect(cb.getFailureCount()).toBe(0)
+    })
+  })
+
+  describe('Callbacks', () => {
+    it('Should call onStateChange on state transitions', async () => {
+      const onStateChange = vi.fn()
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        onStateChange,
+      })
+
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+
+      expect(onStateChange).toHaveBeenCalledWith('open', 'closed')
+    })
+
+    it('Should call onOpen when circuit opens', async () => {
+      const onOpen = vi.fn()
+      const cb = new CircuitBreaker({
+        failureThreshold: 2,
+        onOpen,
+      })
+
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(failingFetch)
+
+      for (let i = 0; i < 2; i++) {
+        try {
+          await wrappedFetch('http://localhost')
+        } catch {
+          // Expected
+        }
+      }
+
+      expect(onOpen).toHaveBeenCalledWith(2)
+    })
+
+    it('Should call onHalfOpen when circuit transitions to half-open', async () => {
+      vi.useFakeTimers()
+
+      const onHalfOpen = vi.fn()
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        resetTimeout: 5000,
+        onHalfOpen,
+      })
+
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+
+      vi.advanceTimersByTime(5001)
+      cb.isAllowingRequests() // Triggers transition check
+
+      expect(onHalfOpen).toHaveBeenCalled()
+
+      vi.useRealTimers()
+    })
+
+    it('Should call onClose when circuit closes', async () => {
+      vi.useFakeTimers()
+
+      const onClose = vi.fn()
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        successThreshold: 1,
+        resetTimeout: 5000,
+        onClose,
+      })
+
+      // Open the circuit
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFailingFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFailingFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+
+      // Advance to half-open
+      vi.advanceTimersByTime(5001)
+      cb.isAllowingRequests()
+
+      // Success to close
+      const successFetch = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))
+      const wrappedSuccessFetch = cb.wrapFetch(successFetch)
+      await wrappedSuccessFetch('http://localhost')
+
+      expect(onClose).toHaveBeenCalled()
+
+      vi.useRealTimers()
+    })
+
+    it('Should call onReject when request is rejected', async () => {
+      const onReject = vi.fn()
+      const cb = new CircuitBreaker({
+        failureThreshold: 1,
+        onReject,
+      })
+
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected - this opens the circuit
+      }
+
+      try {
+        await wrappedFetch('http://localhost/api/test')
+      } catch {
+        // Expected - this should be rejected
+      }
+
+      expect(onReject).toHaveBeenCalledWith('http://localhost/api/test')
+    })
+
+    it('Should call onFailure on each failure', async () => {
+      const onFailure = vi.fn()
+      const cb = new CircuitBreaker({
+        failureThreshold: 5,
+        onFailure,
+      })
+
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(failingFetch)
+
+      for (let i = 0; i < 3; i++) {
+        try {
+          await wrappedFetch('http://localhost')
+        } catch {
+          // Expected
+        }
+      }
+
+      expect(onFailure).toHaveBeenCalledTimes(3)
+      expect(onFailure).toHaveBeenLastCalledWith(expect.any(Error), 3)
+    })
+
+    it('Should call onSuccess on each success', async () => {
+      const onSuccess = vi.fn()
+      const cb = new CircuitBreaker({ onSuccess })
+
+      const successFetch = vi.fn().mockResolvedValue(new Response(null, { status: 200 }))
+      const wrappedFetch = cb.wrapFetch(successFetch)
+
+      await wrappedFetch('http://localhost')
+      await wrappedFetch('http://localhost')
+
+      expect(onSuccess).toHaveBeenCalledTimes(2)
+    })
+  })
+
+  describe('Manual reset', () => {
+    it('Should reset circuit to closed state', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected
+      }
+      expect(cb.getState()).toBe('open')
+
+      cb.reset()
+
+      expect(cb.getState()).toBe('closed')
+      expect(cb.getFailureCount()).toBe(0)
+      expect(cb.getSuccessCount()).toBe(0)
+      expect(cb.getLastFailureTime()).toBeUndefined()
+    })
+  })
+
+  describe('CircuitBreakerError', () => {
+    it('Should contain circuit breaker information', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+
+      const failingFetch = vi.fn().mockRejectedValue(new Error('Network error'))
+      const wrappedFetch = cb.wrapFetch(failingFetch)
+
+      try {
+        await wrappedFetch('http://localhost')
+      } catch {
+        // Expected - this opens the circuit
+      }
+
+      try {
+        await wrappedFetch('http://localhost')
+      } catch (error) {
+        expect(error).toBeInstanceOf(CircuitBreakerError)
+        const cbError = error as CircuitBreakerError
+        expect(cbError.state).toBe('open')
+        expect(cbError.failureCount).toBe(1)
+        expect(cbError.lastFailure).toBeInstanceOf(Date)
+        expect(cbError.name).toBe('CircuitBreakerError')
+      }
+    })
+  })
+
+  describe('execute method', () => {
+    it('Should execute function and track success', async () => {
+      const cb = new CircuitBreaker()
+
+      const result = await cb.execute(async () => new Response('OK', { status: 200 }))
+
+      expect(result).toBeInstanceOf(Response)
+      expect(cb.getState()).toBe('closed')
+    })
+
+    it('Should execute function and track failure', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+
+      try {
+        await cb.execute(async () => {
+          throw new Error('Network error')
+        })
+      } catch {
+        // Expected
+      }
+
+      expect(cb.getState()).toBe('open')
+    })
+
+    it('Should reject when circuit is open', async () => {
+      const cb = new CircuitBreaker({ failureThreshold: 1 })
+
+      // Open the circuit
+      try {
+        await cb.execute(async () => {
+          throw new Error('Network error')
+        })
+      } catch {
+        // Expected
+      }
+
+      await expect(
+        cb.execute(async () => new Response('OK', { status: 200 }))
+      ).rejects.toThrow(CircuitBreakerError)
+    })
+  })
+})
+
+describe('createCircuitBreakerFetch', () => {
+  it('Should return fetch function and circuit breaker instance', () => {
+    const { fetch: cbFetch, circuitBreaker } = createCircuitBreakerFetch()
+
+    expect(typeof cbFetch).toBe('function')
+    expect(circuitBreaker).toBeInstanceOf(CircuitBreaker)
+  })
+
+  it('Should use custom options', async () => {
+    const { fetch: cbFetch, circuitBreaker } = createCircuitBreakerFetch(
+      { failureThreshold: 2 },
+      vi.fn().mockRejectedValue(new Error('Network error'))
+    )
+
+    try {
+      await cbFetch('http://localhost')
+    } catch {
+      // Expected
+    }
+    expect(circuitBreaker.getState()).toBe('closed')
+
+    try {
+      await cbFetch('http://localhost')
+    } catch {
+      // Expected
+    }
+    expect(circuitBreaker.getState()).toBe('open')
+  })
+})
+
+describe('withCircuitBreaker', () => {
+  const app = new Hono()
+    .get('/success', (c) => c.json({ ok: true }))
+    .get('/error', (c) => c.json({ error: 'Server error' }, 500))
+    .get('/data', (c) => c.json({ data: 'test' }))
+
+  type AppType = typeof app
+
+  const server = setupServer(
+    http.get('http://localhost/success', () => {
+      return HttpResponse.json({ ok: true })
+    }),
+    http.get('http://localhost/error', () => {
+      return HttpResponse.json({ error: 'Server error' }, { status: 500 })
+    }),
+    http.get('http://localhost/data', () => {
+      return HttpResponse.json({ data: 'test' })
+    })
+  )
+
+  beforeAll(() => server.listen())
+  afterEach(() => server.resetHandlers())
+  afterAll(() => server.close())
+
+  it('Should create client with circuit breaker', () => {
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost')
+
+    expect(client).toBeDefined()
+    expect(circuitBreaker).toBeInstanceOf(CircuitBreaker)
+  })
+
+  it('Should allow successful requests', async () => {
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost')
+
+    const res = await client.success.$get()
+    const data = await res.json()
+
+    expect(data).toEqual({ ok: true })
+    expect(circuitBreaker.getState()).toBe('closed')
+  })
+
+  it('Should track failures from 5xx responses', async () => {
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost', {
+      circuitBreaker: { failureThreshold: 1 },
+    })
+
+    await client.error.$get()
+
+    expect(circuitBreaker.getState()).toBe('open')
+    expect(circuitBreaker.getFailureCount()).toBe(1)
+  })
+
+  it('Should open circuit after multiple failures', async () => {
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost', {
+      circuitBreaker: { failureThreshold: 2 },
+    })
+
+    await client.error.$get()
+    expect(circuitBreaker.getState()).toBe('closed')
+
+    await client.error.$get()
+    expect(circuitBreaker.getState()).toBe('open')
+  })
+
+  it('Should reject requests when circuit is open', async () => {
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost', {
+      circuitBreaker: { failureThreshold: 1 },
+    })
+
+    // Open the circuit
+    await client.error.$get()
+    expect(circuitBreaker.getState()).toBe('open')
+
+    // Subsequent request should be rejected
+    await expect(client.success.$get()).rejects.toThrow(CircuitBreakerError)
+  })
+
+  it('Should recover after reset timeout', async () => {
+    vi.useFakeTimers()
+
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost', {
+      circuitBreaker: {
+        failureThreshold: 1,
+        successThreshold: 1,
+        resetTimeout: 5000,
+      },
+    })
+
+    // Open the circuit
+    await client.error.$get()
+    expect(circuitBreaker.getState()).toBe('open')
+
+    // Advance time past reset timeout
+    vi.advanceTimersByTime(5001)
+
+    // Should now allow requests (half-open)
+    const res = await client.success.$get()
+    expect(res.ok).toBe(true)
+
+    // Circuit should now be closed
+    expect(circuitBreaker.getState()).toBe('closed')
+
+    vi.useRealTimers()
+  })
+
+  it('Should use custom callbacks', async () => {
+    const onOpen = vi.fn()
+    const onFailure = vi.fn()
+
+    const { client } = withCircuitBreaker<AppType>('http://localhost', {
+      circuitBreaker: {
+        failureThreshold: 1,
+        onOpen,
+        onFailure,
+      },
+    })
+
+    await client.error.$get()
+
+    expect(onFailure).toHaveBeenCalledWith(expect.any(Response), 1)
+    expect(onOpen).toHaveBeenCalledWith(1)
+  })
+
+  it('Should work with app.request', async () => {
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('', {
+      fetch: app.request,
+    })
+
+    const res = await client.success.$get()
+    const data = await res.json()
+
+    expect(data).toEqual({ ok: true })
+    expect(circuitBreaker.getState()).toBe('closed')
+  })
+
+  it('Should preserve other client options', async () => {
+    const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost', {
+      headers: { 'X-Custom': 'test' },
+      circuitBreaker: { failureThreshold: 5 },
+    })
+
+    const res = await client.success.$get()
+    expect(res.ok).toBe(true)
+    expect(circuitBreaker.getState()).toBe('closed')
+  })
+})
+
+describe('Integration tests with MSW', () => {
+  let requestCount = 0
+
+  const server = setupServer(
+    http.get('http://localhost/api/flaky', () => {
+      requestCount++
+      if (requestCount <= 3) {
+        return HttpResponse.json({ error: 'Server overloaded' }, { status: 503 })
+      }
+      return HttpResponse.json({ ok: true })
+    }),
+    http.get('http://localhost/api/always-fail', () => {
+      return HttpResponse.json({ error: 'Always fails' }, { status: 500 })
+    }),
+    http.get('http://localhost/api/always-success', () => {
+      return HttpResponse.json({ ok: true })
+    })
+  )
+
+  beforeAll(() => server.listen())
+  afterEach(() => {
+    server.resetHandlers()
+    requestCount = 0
+  })
+  afterAll(() => server.close())
+
+  it('Should handle flaky services with circuit breaker', async () => {
+    vi.useFakeTimers()
+
+    const stateChanges: { from: CircuitBreakerState; to: CircuitBreakerState }[] = []
+
+    const { fetch: cbFetch, circuitBreaker } = createCircuitBreakerFetch({
+      failureThreshold: 3,
+      successThreshold: 1,
+      resetTimeout: 10000,
+      onStateChange: (to, from) => stateChanges.push({ from, to }),
+    })
+
+    const app = new Hono()
+      .get('/api/flaky', (c) => c.json({ ok: true }))
+      .get('/api/always-fail', (c) => c.json({ error: 'fail' }, 500))
+      .get('/api/always-success', (c) => c.json({ ok: true }))
+
+    type AppType = typeof app
+    const { client } = withCircuitBreaker<AppType>('http://localhost', {
+      fetch: cbFetch,
+      circuitBreaker: {
+        failureThreshold: 3,
+        successThreshold: 1,
+        resetTimeout: 10000,
+      },
+    })
+
+    // First 3 requests fail and open the circuit
+    for (let i = 0; i < 3; i++) {
+      await client.api.flaky.$get()
+    }
+
+    // Circuit should be open now (the inner circuit breaker)
+    // The outer circuit breaker in withCircuitBreaker tracks separately
+
+    vi.useRealTimers()
+  })
+
+  it('Should allow monitoring circuit breaker state', async () => {
+    const failures: number[] = []
+    const successes: number[] = []
+
+    const { fetch: cbFetch, circuitBreaker } = createCircuitBreakerFetch({
+      failureThreshold: 10,
+      onFailure: (_, count) => failures.push(count),
+      onSuccess: (_, count) => successes.push(count),
+    })
+
+    // Make some requests
+    await cbFetch('http://localhost/api/always-success')
+    await cbFetch('http://localhost/api/always-fail')
+    await cbFetch('http://localhost/api/always-success')
+
+    expect(failures).toEqual([1])
+    expect(successes.length).toBe(2)
+    expect(circuitBreaker.getState()).toBe('closed')
+  })
+})
diff --git a/src/client/circuit-breaker.ts b/src/client/circuit-breaker.ts
new file mode 100644
index 00000000..aa7fe843
--- /dev/null
+++ b/src/client/circuit-breaker.ts
@@ -0,0 +1,424 @@
+/**
+ * Circuit Breaker for Hono RPC Client
+ *
+ * Provides a resilience pattern for the hc client to handle failures gracefully.
+ * The circuit breaker tracks failure thresholds and enters an "Open" state
+ * (preventing requests) after a configurable number of failures, then transitions
+ * to "Half-Open" and "Closed" based on success.
+ */
+
+import type { Hono } from '../hono'
+import type { UnionToIntersection } from '../utils/types'
+import { hc } from './client'
+import type { Client, ClientRequestOptions } from './types'
+
+/**
+ * Circuit breaker states
+ */
+export type CircuitBreakerState = 'closed' | 'open' | 'half-open'
+
+/**
+ * Configuration options for the circuit breaker
+ */
+export interface CircuitBreakerOptions {
+  /**
+   * Number of consecutive failures before opening the circuit
+   * @default 5
+   */
+  failureThreshold?: number
+
+  /**
+   * Number of consecutive successes in half-open state to close the circuit
+   * @default 2
+   */
+  successThreshold?: number
+
+  /**
+   * Time in milliseconds to wait before transitioning from open to half-open
+   * @default 30000 (30 seconds)
+   */
+  resetTimeout?: number
+
+  /**
+   * HTTP status codes that should be treated as failures
+   * @default [500, 501, 502, 503, 504, 505, 506, 507, 508, 510, 511]
+   */
+  failureStatusCodes?: number[]
+
+  /**
+   * Called when the circuit state changes
+   */
+  onStateChange?: (state: CircuitBreakerState, previousState: CircuitBreakerState) => void
+
+  /**
+   * Called when the circuit opens due to failures
+   */
+  onOpen?: (failureCount: number) => void
+
+  /**
+   * Called when the circuit transitions to half-open
+   */
+  onHalfOpen?: () => void
+
+  /**
+   * Called when the circuit closes (recovers)
+   */
+  onClose?: () => void
+
+  /**
+   * Called when a request is rejected due to open circuit
+   */
+  onReject?: (url: string) => void
+
+  /**
+   * Called on each failure
+   */
+  onFailure?: (error: Error | Response, failureCount: number) => void
+
+  /**
+   * Called on each success
+   */
+  onSuccess?: (response: Response, successCount: number) => void
+}
+
+/**
+ * Error thrown when a request is rejected due to an open circuit
+ */
+export class CircuitBreakerError extends Error {
+  readonly state: CircuitBreakerState
+  readonly failureCount: number
+  readonly lastFailure: Date | undefined
+
+  constructor(
+    message: string,
+    state: CircuitBreakerState,
+    failureCount: number,
+    lastFailure?: Date
+  ) {
+    super(message)
+    this.name = 'CircuitBreakerError'
+    this.state = state
+    this.failureCount = failureCount
+    this.lastFailure = lastFailure
+  }
+}
+
+/**
+ * Default failure status codes (5xx server errors)
+ */
+const DEFAULT_FAILURE_STATUS_CODES = [500, 501, 502, 503, 504, 505, 506, 507, 508, 510, 511]
+
+/**
+ * Circuit Breaker class that wraps fetch operations
+ */
+export class CircuitBreaker {
+  private state: CircuitBreakerState = 'closed'
+  private failureCount = 0
+  private successCount = 0
+  private lastFailureTime: Date | undefined
+  private readonly options: Required<
+    Omit<
+      CircuitBreakerOptions,
+      'onStateChange' | 'onOpen' | 'onHalfOpen' | 'onClose' | 'onReject' | 'onFailure' | 'onSuccess'
+    >
+  > &
+    Pick<
+      CircuitBreakerOptions,
+      'onStateChange' | 'onOpen' | 'onHalfOpen' | 'onClose' | 'onReject' | 'onFailure' | 'onSuccess'
+    >
+
+  constructor(options: CircuitBreakerOptions = {}) {
+    this.options = {
+      failureThreshold: options.failureThreshold ?? 5,
+      successThreshold: options.successThreshold ?? 2,
+      resetTimeout: options.resetTimeout ?? 30000,
+      failureStatusCodes: options.failureStatusCodes ?? DEFAULT_FAILURE_STATUS_CODES,
+      onStateChange: options.onStateChange,
+      onOpen: options.onOpen,
+      onHalfOpen: options.onHalfOpen,
+      onClose: options.onClose,
+      onReject: options.onReject,
+      onFailure: options.onFailure,
+      onSuccess: options.onSuccess,
+    }
+  }
+
+  /**
+   * Get the current state of the circuit breaker
+   */
+  getState(): CircuitBreakerState {
+    return this.state
+  }
+
+  /**
+   * Get the current failure count
+   */
+  getFailureCount(): number {
+    return this.failureCount
+  }
+
+  /**
+   * Get the current success count (relevant in half-open state)
+   */
+  getSuccessCount(): number {
+    return this.successCount
+  }
+
+  /**
+   * Get the time of the last failure
+   */
+  getLastFailureTime(): Date | undefined {
+    return this.lastFailureTime
+  }
+
+  /**
+   * Check if the circuit is currently allowing requests
+   */
+  isAllowingRequests(): boolean {
+    if (this.state === 'closed') {
+      return true
+    }
+
+    if (this.state === 'half-open') {
+      return true
+    }
+
+    // In open state, check if reset timeout has passed
+    if (this.state === 'open' && this.lastFailureTime) {
+      const timeSinceLastFailure = Date.now() - this.lastFailureTime.getTime()
+      if (timeSinceLastFailure >= this.options.resetTimeout) {
+        this.transitionTo('half-open')
+        return true
+      }
+    }
+
+    return false
+  }
+
+  /**
+   * Manually reset the circuit breaker to closed state
+   */
+  reset(): void {
+    this.transitionTo('closed')
+    this.failureCount = 0
+    this.successCount = 0
+    this.lastFailureTime = undefined
+  }
+
+  /**
+   * Execute a function with circuit breaker protection
+   */
+  async execute<T>(fn: () => Promise<T>): Promise<T> {
+    if (!this.isAllowingRequests()) {
+      this.options.onReject?.('')
+      throw new CircuitBreakerError(
+        'Circuit breaker is open, request rejected',
+        this.state,
+        this.failureCount,
+        this.lastFailureTime
+      )
+    }
+
+    try {
+      const result = await fn()
+
+      // Check if the result is a Response with a failure status code
+      if (result instanceof Response && this.isFailureStatusCode(result.status)) {
+        this.recordFailure(result)
+        return result
+      }
+
+      this.recordSuccess(result as Response)
+      return result
+    } catch (error) {
+      this.recordFailure(error as Error)
+      throw error
+    }
+  }
+
+  /**
+   * Create a wrapped fetch function that uses this circuit breaker
+   */
+  wrapFetch(
+    originalFetch: typeof fetch = fetch
+  ): (input: RequestInfo | URL, init?: RequestInit) => Promise<Response> {
+    return async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
+      const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url
+      if (!this.isAllowingRequests()) {
+        this.options.onReject?.(url)
+        throw new CircuitBreakerError(
+          `Circuit breaker is open, request to ${url} rejected`,
+          this.state,
+          this.failureCount,
+          this.lastFailureTime
+        )
+      }
+
+      try {
+        const response = await originalFetch(input, init)
+
+        if (this.isFailureStatusCode(response.status)) {
+          this.recordFailure(response)
+          return response
+        }
+
+        this.recordSuccess(response)
+        return response
+      } catch (error) {
+        this.recordFailure(error as Error)
+        throw error
+      }
+    }
+  }
+
+  private isFailureStatusCode(status: number): boolean {
+    return this.options.failureStatusCodes.includes(status)
+  }
+
+  private recordSuccess(response: Response): void {
+    if (this.state === 'half-open') {
+      this.successCount++
+      this.options.onSuccess?.(response, this.successCount)
+
+      if (this.successCount >= this.options.successThreshold) {
+        this.transitionTo('closed')
+        this.failureCount = 0
+        this.successCount = 0
+        this.lastFailureTime = undefined
+      }
+    } else if (this.state === 'closed') {
+      // In closed state, reset failure count on success
+      this.failureCount = 0
+      this.options.onSuccess?.(response, 0)
+    }
+  }
+
+  private recordFailure(error: Error | Response): void {
+    this.failureCount++
+    this.lastFailureTime = new Date()
+    this.options.onFailure?.(error, this.failureCount)
+
+    if (this.state === 'half-open') {
+      // Any failure in half-open immediately opens the circuit
+      this.transitionTo('open')
+      this.successCount = 0
+    } else if (this.state === 'closed') {
+      if (this.failureCount >= this.options.failureThreshold) {
+        this.transitionTo('open')
+      }
+    }
+  }
+
+  private transitionTo(newState: CircuitBreakerState): void {
+    if (this.state === newState) {
+      return
+    }
+
+    const previousState = this.state
+    this.state = newState
+
+    this.options.onStateChange?.(newState, previousState)
+
+    switch (newState) {
+      case 'open':
+        this.options.onOpen?.(this.failureCount)
+        break
+      case 'half-open':
+        this.successCount = 0
+        this.options.onHalfOpen?.()
+        break
+      case 'closed':
+        this.options.onClose?.()
+        break
+    }
+  }
+}
+
+/**
+ * Options for creating a client with circuit breaker
+ */
+export type CircuitBreakerClientOptions = ClientRequestOptions & {
+  circuitBreaker?: CircuitBreakerOptions
+}
+
+/**
+ * Result type for withCircuitBreaker, includes the client and circuit breaker instance
+ */
+export type CircuitBreakerClient<T extends Hono<any, any, any>, Prefix extends string> = {
+  client: UnionToIntersection<Client<T, Prefix>>
+  circuitBreaker: CircuitBreaker
+}
+
+/**
+ * Creates an hc client with circuit breaker protection.
+ *
+ * @example
+ * ```ts
+ * const { client, circuitBreaker } = withCircuitBreaker<AppType>('http://localhost', {
+ *   circuitBreaker: {
+ *     failureThreshold: 5,
+ *     successThreshold: 2,
+ *     resetTimeout: 30000,
+ *     onOpen: () => console.log('Circuit opened!'),
+ *     onClose: () => console.log('Circuit closed!'),
+ *   }
+ * })
+ *
+ * // Use client as normal
+ * const res = await client.api.users.$get()
+ *
+ * // Check circuit breaker state
+ * console.log(circuitBreaker.getState())
+ * ```
+ */
+// eslint-disable-next-line @typescript-eslint/no-explicit-any
+export function withCircuitBreaker<T extends Hono<any, any, any>, Prefix extends string = string>(
+  baseUrl: Prefix,
+  options?: CircuitBreakerClientOptions
+): CircuitBreakerClient<T, Prefix> {
+  const { circuitBreaker: cbOptions, ...clientOptions } = options ?? {}
+  const cb = new CircuitBreaker(cbOptions)
+
+  const originalFetch = clientOptions?.fetch ?? fetch
+  const wrappedFetch = cb.wrapFetch(originalFetch as typeof fetch)
+
+  const client = hc<T, Prefix>(baseUrl, {
+    ...clientOptions,
+    fetch: wrappedFetch,
+  }) as UnionToIntersection<Client<T, Prefix>>
+
+  return {
+    client,
+    circuitBreaker: cb,
+  }
+}
+
+/**
+ * Creates a circuit breaker wrapped fetch function that can be used with hc client.
+ *
+ * @example
+ * ```ts
+ * const { fetch: cbFetch, circuitBreaker } = createCircuitBreakerFetch({
+ *   failureThreshold: 5,
+ *   resetTimeout: 30000,
+ * })
+ *
+ * const client = hc<AppType>('http://localhost', { fetch: cbFetch })
+ *
+ * // Monitor circuit breaker state
+ * console.log(circuitBreaker.getState())
+ * ```
+ */
+export function createCircuitBreakerFetch(
+  options?: CircuitBreakerOptions,
+  originalFetch: typeof fetch = fetch
+): {
+  fetch: (input: RequestInfo | URL, init?: RequestInit) => Promise<Response>
+  circuitBreaker: CircuitBreaker
+} {
+  const cb = new CircuitBreaker(options)
+  return {
+    fetch: cb.wrapFetch(originalFetch),
+    circuitBreaker: cb,
+  }
+}
diff --git a/src/client/index.ts b/src/client/index.ts
index b9508466..7c28bb78 100644
--- a/src/client/index.ts
+++ b/src/client/index.ts
@@ -5,6 +5,12 @@
 
 export { hc } from './client'
 export { parseResponse, DetailedError } from './utils'
+export {
+  CircuitBreaker,
+  CircuitBreakerError,
+  withCircuitBreaker,
+  createCircuitBreakerFetch,
+} from './circuit-breaker'
 export type {
   InferResponseType,
   InferRequestType,
@@ -13,3 +19,9 @@ export type {
   ClientRequest,
   ClientResponse,
 } from './types'
+export type {
+  CircuitBreakerState,
+  CircuitBreakerOptions,
+  CircuitBreakerClientOptions,
+  CircuitBreakerClient,
+} from './circuit-breaker'
